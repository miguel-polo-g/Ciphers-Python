# -*- coding: utf-8 -*-
"""Info_Sec_Mgt_Notebook

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1e6BO7NytBTCMfKhx2bAQFFenPZKvtgU6

## Week 1 - Python

#####hex2base64
"""

import codecs

def hex2base64(s):
  # Convert string to hex
  s = '0'*(len(s)%2) + s
  hexnum = codecs.decode(s, 'hex')
  print(hexnum)
  print("hexnum: " + hexnum.hex())
  
  # Encode as base64 (bytes)
  b64num = codecs.encode(hexnum, 'base64')
  print("base64: " + b64num.decode("utf-8"))

s = 'd04988522ddfed3133cc24fb6924eae9'
hex2base64(s)

"""#####String and lists"""

import random

def convert(s):
    new = ""
    for x in s:
        new += x
    return new

#Generate 20 random numbers between 0x41=65 and 0x5a=90
randomlist = random.sample(range(65, 90), 20)
print(randomlist)

characters = [chr(n) for n in randomlist]
print(characters)

str = convert(characters)
print(str)

str = str.lower()
print(str)

result = str[2:10]
result = result + result
print(result)

"""## Week 2 - Converting formats

#####hex2base64 without libraries
"""

def fillupbyte(s):
  while len(s)%8 != 0:
    s = '0' + s
  return s

def rightpadding(s):
  while len(s)%6 != 0:
    s = s + '0'
  return s

def finalpadding(s):
  while len(s)%4 != 0:
    s = s + '='
  return s

def encode(bits):
  values =  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  result = ""
  for i in range(len(bits)):
    if i%6 == 0:
      index = int(bits[i:i+6], 2)
      result+=values[int(index)]
  return result

def hex2base64nolib(value):
  binnum = bin(int(value, 16))[2:]
  strng8 = fillupbyte(binnum)
  strng6 = rightpadding(strng8)
  encoded = encode(strng6)
  result = finalpadding(encoded)
  return result

s = '3d54'

print("hexnum: " + s)
print("base64: " + hex2base64nolib(s))

"""##Week 3 - Simple encryptions

#####Find the key of a single byte xor encryption
"""

encryptedhex = 'e9c88081f8ced481c9c0d7c481c7ced4cfc581ccc480'

def hex2string(h):
  ascii_string = ""
  for i in range(0,len(h),2):
    ascii_string += chr(int(h[i:i+2],16))
  return ascii_string

def string2hex(s):
  hex_string = ""
  for c in s:
    hex_string += hex(ord(c))[2:]
  return hex_string

def hex_xor(hex1,hex2):
  result = ""
  bin1 = bin(int(hex1, 16))[2:].rjust(max(len(hex1),len(hex2))*4,'0')
  bin2 = bin(int(hex2, 16))[2:].rjust(max(len(hex1),len(hex2))*4,'0')
  for b in range(0,len(bin1)):
    if bin1[b] == bin2[b]:
      result += '0'
    else:
      result += '1'
  return hex(int(result,2))[2:]

def encrypt_single_byte_xor(hexnum,byte):
  result = ""
  for i in range(0,len(hexnum),2):
    result += hex_xor(hexnum[i:i+2],byte)
  return result

def findoriginal():
  for i in range(0,256):
    print("used byte:", hex(i)[2:], " --- decryption:", hex2string(encrypt_single_byte_xor(encryptedhex,hex(i)[2:])))

#findoriginal()
print("encrypted hex:", encryptedhex)
print("decryption:",hex2string(encrypt_single_byte_xor(encryptedhex,'a1')))
# ORIGINAL TEXT: Hi! You have found me!

"""##Week 4 - Pre exam exercises

#####Text ecryption scheme with one byte key + add modulo 256
"""

def hex2string(h):
  ascii_string = ""
  for i in range(0,len(h),2):
    ascii_string += chr(int(h[i:i+2],16))
  return ascii_string

def string2hex(s):
  hex_string = ""
  for c in s:
    hex_string += hex(ord(c))[2:]
  return hex_string

def add_modulo_256(hexnum,byte):
  result = ""
  for i in range(0,len(hexnum),2):
    result += hex((int(hexnum[i:i+2],16)+int(byte,16))%256)[2:]
  return result

def encrypt_by_add_mod(text,num):
  hexnum = hex(num%256)[2:]
  hextext = string2hex(text)
  return hex2string(add_modulo_256(hextext,hexnum))


print(encrypt_by_add_mod('Hello',123))
print(encrypt_by_add_mod(encrypt_by_add_mod('Hello',123),133))
print(encrypt_by_add_mod(encrypt_by_add_mod('Cryptography',100),156))

"""#####Text ecryption scheme with changing key by previous cipher"""

def hex2string(h):
  ascii_string = ""
  for i in range(0,len(h),2):
    ascii_string += chr(int(h[i:i+2],16))
  return ascii_string

def string2hex(s):
  hex_string = ""
  for c in s:
    solution = hex(ord(c))[2:]
    if len(solution)==1:
      solution = fillupbyte(solution)
    hex_string += solution
  return hex_string

def fillupbyte(s):
  while len(s)%2 != 0:
    s = '0' + s
  return s

def hex_xor(hex1,hex2):
  result = ""
  bin1 = bin(int(hex1, 16))[2:].rjust(max(len(hex1),len(hex2))*4,'0')
  bin2 = bin(int(hex2, 16))[2:].rjust(max(len(hex1),len(hex2))*4,'0')
  for b in range(0,len(bin1)):
    if bin1[b] == bin2[b]:
      result += '0'
    else:
      result += '1'
  solution = hex(int(result,2))[2:]
  if len(solution)==1:
    solution = fillupbyte(solution)
  return solution

def encrypt_xor_with_changing_key_by_prev_cipher(text,num,enc_dec):
  result = ""
  byte = hex(num%256)[2:]
  hextext = string2hex(text)

  if enc_dec == "encrypt":
    for i in range(0,len(hextext),2):
      if i == 0:
        result += hex_xor(hextext[i:i+2],byte)
      else:
        result += hex_xor(hextext[i:i+2],hextext[i-2:i])
    return hex2string(result)
  
  if enc_dec == "decrypt":
    for i in range(0,len(hextext),2):
      if i == 0:
        result += hex_xor(hextext[i:i+2],byte)
      else:
        result += hex_xor(hextext[i:i+2],result[i-2:i])
    return hex2string(result)
  
  else:
    return "Invalid arguments"

print(encrypt_xor_with_changing_key_by_prev_cipher('Hello',123,'encrypt'))
print(encrypt_xor_with_changing_key_by_prev_cipher(encrypt_xor_with_changing_key_by_prev_cipher('Hello',123,'encrypt'),123,'decrypt'))
print(encrypt_xor_with_changing_key_by_prev_cipher(encrypt_xor_with_changing_key_by_prev_cipher('Cryptography',10,'encrypt'),10,'decrypt'))

"""#####Week 5 Exam - Task 1"""

def hex2string(h):
  ascii_string = ""
  for i in range(0,len(h),2):
    ascii_string += chr(int(h[i:i+2],16))
  return ascii_string

def string2hex(s):
  hex_string = ""
  for c in s:
    solution = hex(ord(c))[2:]
    if len(solution)==1:
      solution = fillupbyte(solution)
    hex_string += solution
  return hex_string

def fillupbyte(s):
  while len(s)%2 != 0:
    s = '0' + s
  return s

def hex_xor(hex1,hex2):
  result = ""
  bin1 = bin(int(hex1, 16))[2:].rjust(max(len(hex1),len(hex2))*4,'0')
  bin2 = bin(int(hex2, 16))[2:].rjust(max(len(hex1),len(hex2))*4,'0')
  for b in range(0,len(bin1)):
    if bin1[b] == bin2[b]:
      result += '0'
    else:
      result += '1'
  solution = hex(int(result,2))[2:]
  if len(solution)==1:
    solution = fillupbyte(solution)
  return solution

def power_modulo_256(byte):
  return hex((int(byte,16)**2)%256)[2:]

def encrypt_with_power(text,num):
  result = ""
  byte = hex(num%256)[2:]
  hextext = string2hex(text)
  for i in range(0,len(hextext),2):
    if i == 0:
      result += hex_xor(hextext[i:i+2],byte)
    else:
      byte = power_modulo_256(byte)
      result += hex_xor(hextext[i:i+2],byte)
  return hex2string(result)

print(encrypt_with_power('Hello',250))
print(encrypt_with_power(encrypt_with_power('Hello',123),123))
print(encrypt_with_power(encrypt_with_power('Cryptography',10),10))

"""#####Task 2"""

def hex2string(h):
  ascii_string = ""
  for i in range(0,len(h),2):
    ascii_string += chr(int(h[i:i+2],16))
  return ascii_string

def string2hex(s):
  hex_string = ""
  for c in s:
    solution = hex(ord(c))[2:]
    if len(solution)==1:
      solution = fillupbyte(solution)
    hex_string += solution
  return hex_string

def fillupbyte(s):
  while len(s)%2 != 0:
    s = '0' + s
  return s

def hex_xor(hex1,hex2):
  result = ""
  bin1 = bin(int(hex1, 16))[2:].rjust(max(len(hex1),len(hex2))*4,'0')
  bin2 = bin(int(hex2, 16))[2:].rjust(max(len(hex1),len(hex2))*4,'0')
  for b in range(0,len(bin1)):
    if bin1[b] == bin2[b]:
      result += '0'
    else:
      result += '1'
  solution = hex(int(result,2))[2:]
  if len(solution)==1:
    solution = fillupbyte(solution)
  return solution

def power_modulo_256(byte):
  return hex((int(byte,16)**2)%256)[2:]

def encrypt_with_power2(text,num,enc_dec):
  result = ""
  byte = hex(num%256)[2:]
  hextext = string2hex(text)

  if enc_dec == "encrypt":
    for i in range(0,len(hextext),2):
      if i == 0:
        result += hex_xor(hextext[i:i+2],byte)
      else:
        byte = power_modulo_256(byte)
        if byte == 0 or byte == 1:
          result += hex_xor(hextext[i:i+2],hextext[i-2:i])
        else:
          result += hex_xor(hextext[i:i+2],byte)
    return hex2string(result)
  
  if enc_dec == "decrypt":
    for i in range(0,len(hextext),2):
      if i == 0:
        result += hex_xor(hextext[i:i+2],byte)
      else:
        byte = power_modulo_256(byte)
        if byte == 0 or byte == 1:
          result += hex_xor(hextext[i:i+2],result[i-2:i])
        else:
          result += hex_xor(hextext[i:i+2],byte)
    return hex2string(result)

  else:
    return "Invalid arguments"
  

print(encrypt_with_power2('Hello',253,'encrypt'))
print(encrypt_with_power2('Hello2',131,'encrypt'))
print(encrypt_with_power2(encrypt_with_power2('Hello',123,'encrypt'),123,'decrypt'))
print(encrypt_with_power2(encrypt_with_power2('Cryptography',10,'encrypt'),10,'decrypt'))

"""#####Task 3"""

def fillupbyte(s):
  while len(s)%8 != 0:
    s = '0' + s
  return s

def swap_lower_and_upper_bits(num):
  result = ""
  hexnum = hex(num)[2:]
  binnum = bin(int(hexnum, 16))[2:]
  binnum = fillupbyte(binnum)
  for i in range(0,len(binnum),4):
    result += binnum[len(binnum)-4-i:len(binnum)-i]
  return int(result,2)

print(swap_lower_and_upper_bits(0))
print(swap_lower_and_upper_bits(1))
print(swap_lower_and_upper_bits(2))
print(swap_lower_and_upper_bits(8))
print(bin(swap_lower_and_upper_bits(0b1111)))
print(bin(swap_lower_and_upper_bits(0b10011010)))

"""#####Task 4"""

def hex2string(h):
  ascii_string = ""
  for i in range(0,len(h),2):
    ascii_string += chr(int(h[i:i+2],16))
  return ascii_string

def string2hex(s):
  hex_string = ""
  for c in s:
    solution = hex(ord(c))[2:]
    if len(solution)==1:
      solution = fillupbyte(solution)
    hex_string += solution
  return hex_string

def fillupbyte(s):
  while len(s)%2 != 0:
    s = '0' + s
  return s

def fillupbyte8(s):
  while len(s)%8 != 0:
    s = '0' + s
  return s

def swap_lower_and_upper_bits(num):
  result = ""
  hexnum = hex(num)[2:]
  binnum = bin(int(hexnum, 16))[2:]
  binnum = fillupbyte8(binnum)
  for i in range(0,len(binnum),4):
    result += binnum[len(binnum)-4-i:len(binnum)-i]
  return int(result,2)

def hex_xor(hex1,hex2):
  result = ""
  bin1 = bin(int(hex1, 16))[2:].rjust(max(len(hex1),len(hex2))*4,'0')
  bin2 = bin(int(hex2, 16))[2:].rjust(max(len(hex1),len(hex2))*4,'0')
  for b in range(0,len(bin1)):
    if bin1[b] == bin2[b]:
      result += '0'
    else:
      result += '1'
  solution = hex(int(result,2))[2:]
  if len(solution)==1:
    solution = fillupbyte(solution)
  return solution

def power_modulo_256(byte):
  result = hex((int(byte,16)**2)%256)[2:]
  if len(result)==1:
    result = fillupbyte(result)
  return result

def encrypt_with_power_and_swap(text,num,enc_dec):
  result = ""
  byte = hex(num%256)[2:]
  hextext = string2hex(text)

  if enc_dec == "encrypt":
    for i in range(0,len(hextext),2):
      if i == 0:
        result += hex_xor(hex(swap_lower_and_upper_bits(int(hextext[i:i+2],16)))[2:],hex(swap_lower_and_upper_bits(int(byte,16)))[2:])
      else:
        byte = power_modulo_256(byte)
        if int(byte,16) == 0 or int(byte,16) == 1:
          newbyte = hextext[i-2:i]
          byte = newbyte
          result += hex_xor(hex(swap_lower_and_upper_bits(int(hextext[i:i+2],16)))[2:],hex(swap_lower_and_upper_bits(int(newbyte,16)))[2:])
        else:
          solution = hex_xor(hex(swap_lower_and_upper_bits(int(hextext[i:i+2],16)))[2:],hex(swap_lower_and_upper_bits(int(byte,16)))[2:])
          if len(solution)==1:
            solution = fillupbyte(solution)
          result += solution
    return hex2string(result)
  
  if enc_dec == "decrypt":
    for i in range(0,len(hextext),2):
      if i == 0:
        result += hex(swap_lower_and_upper_bits(int(hex_xor(hextext[i:i+2],hex(swap_lower_and_upper_bits(int(byte,16)))),16)))[2:]
      else:
        byte = power_modulo_256(byte)
        if int(byte,16) == 0 or int(byte,16) == 1:
          newbyte = result[i-2:i]
          byte = newbyte
          result += hex(swap_lower_and_upper_bits(int(hex_xor(hextext[i:i+2],hex(swap_lower_and_upper_bits(int(newbyte,16)))),16)))[2:]
        else:
          solution = hex(swap_lower_and_upper_bits(int(hex_xor(hextext[i:i+2],hex(swap_lower_and_upper_bits(int(byte,16)))),16)))[2:]
          if len(solution)==1:
            solution = fillupbyte(solution)
          result += solution
    return hex2string(result)

  else:
    return "Invalid arguments"

print(encrypt_with_power_and_swap('Hello',11,'encrypt'))
print(encrypt_with_power_and_swap(encrypt_with_power_and_swap('Hello',123,'encrypt'),123,'decrypt'))
print(encrypt_with_power_and_swap(encrypt_with_power_and_swap('Cryptography',12,'encrypt'),12,'decrypt'))

"""##Week 6 - Block cipher 1"""

pip install pycryptodome

from Crypto.Cipher import AES

key = bytes([57, 226, 240, 61, 125, 240, 75, 68, 22, 35, 124, 205, 144, 27, 118, 220])
iv = bytes([241, 147, 66, 129, 194, 34, 37, 51, 236, 69, 188, 205, 64, 140, 244, 204])

def decrypt_aes(bytarray,key,iv):
  cipher = AES.new(key, AES.MODE_CBC, iv)
  return cipher.decrypt(bytarray)

def bit_permutation(bits, array):
  if len(bits) < len(array):
    return "Invalid arguments"
  else:
    result = ""
    for i in array:
      result += bits[i-1] 
    return result

def bit_rotation(bits):
  result = bits[1:] + bits[0]
  return result

def left_shift_rot(bits, steps=1):
  result = bits
  for i in range(steps):
    result = bit_rotation(result)
  return result

def PKCS7_pad(text,steps):
  pad = steps - int(len(text))
  if pad < 0 or pad >= 128:
    return "Invalid padding"
  else:
    return bytes(text + chr(pad)*pad,"ascii")

print(decrypt_aes(bytes([255, 18, 67, 115, 172, 117, 242, 233, 246, 69, 81, 156, 52, 154, 123, 171]),key,iv))
print(decrypt_aes(bytes([171, 218, 160, 96, 193, 134, 73, 81, 221, 149, 19, 180, 31, 247, 106, 64]),key,iv))

print(bit_permutation("101",[1,2,3]))
print(bit_permutation("101",[3,2,1]))
print(bit_permutation("101",[1,3,2]))
print(bit_permutation("1010",[3,4,1,2]))
print(bit_permutation("1010",[1,3,2,4]))
print(bit_permutation("11110000",[5,6,7,8,1,2,3,4]))
print(bit_permutation("0001001100110100010101110111100110011011101111001101111111110001",[57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4]))

print("\n",left_shift_rot('010'))
print(left_shift_rot('111'))
print(left_shift_rot('1010111001'))
print(left_shift_rot('0101110011'))
print(left_shift_rot('1010111001',2))
print(left_shift_rot('0001',3))

print("\n",PKCS7_pad('hello',6))
print(PKCS7_pad('hello',7))
print(PKCS7_pad('hello, how are you?',26))
print(PKCS7_pad('hello, how are you?',55))
print(PKCS7_pad('hello, how are you?',67))

"""##Week 7 - Block cipher 2"""

from Crypto.Cipher import AES

key = bytes([57, 226, 240, 61, 125, 240, 75, 68, 22, 35, 124, 205, 144, 27, 118, 220])
iv = bytes([241, 147, 66, 129, 194, 34, 37, 51, 236, 69, 188, 205, 64, 140, 244, 204])

def decrypt_aes_ecb(bytarray,key):
  cipher = AES.new(key, AES.MODE_ECB)
  return cipher.decrypt(bytarray)

def encrypt_aes_ecb(bytarray,key):
  cipher = AES.new(key, AES.MODE_ECB)
  return cipher.encrypt(bytarray)

def xor_byte_arrays(bytarray1,bytarray2):
  padded1 = bytarray1.rjust(max(len(bytarray1),len(bytarray2)), bytes([0]))
  padded2 = bytarray2.rjust(max(len(bytarray1),len(bytarray2)), bytes([0]))
  parts = []
  for padded1, padded2 in zip(padded1, padded2):
    parts.append(bytes([padded1 ^ padded2]))
  return b''.join(parts)

def decrypt_aes_cbc_with_ecb(bytarray,key,iv):
  result = []
  for i in range(0,len(bytarray),16):
    if i==0:
      result.append( xor_byte_arrays( decrypt_aes_ecb(bytarray[i:i+16],key), iv ) )
    else:
      result.append( xor_byte_arrays( decrypt_aes_ecb(bytarray[i:i+16],key), bytarray[i-16:i] ) )
  return b''.join(result)

def encrypt_aes_cbc_with_ecb(bytarray,key,iv):
  result = []
  for i in range(0,len(bytarray),16):
    if i==0:
      ithbytes = bytarray[i:i+16]
      result.append( encrypt_aes_ecb( xor_byte_arrays(ithbytes,iv) ,key) )
    else:
      ithbyte = bytarray[i:i+16]
      result.append( encrypt_aes_ecb( xor_byte_arrays(ithbyte, result[i-1]) ,key) )
  return b''.join(result)

print(decrypt_aes_ecb(bytes([215, 221, 59, 138, 96, 94, 155, 69, 52, 90, 212, 108, 49, 65, 138, 179]),key))
print(decrypt_aes_ecb(bytes([147, 140, 44, 177, 97, 209, 42, 239, 152, 124, 241, 175, 202, 164, 183, 18]),key),"\n")

print(xor_byte_arrays(bytes([1,2,3,4]),bytes([2,3,4,5])))
print(xor_byte_arrays(bytes([1,2,3,4]),bytes([])))
print(xor_byte_arrays(bytes([1,2,3,4]),bytes([1,2])))
print(xor_byte_arrays(bytes([1,2,4,8,16,32,64,128]),bytes([1,1,1,1,1,1,1,1])),"\n")

print(decrypt_aes_cbc_with_ecb(bytes([255, 18, 67, 115, 172, 117, 242, 233, 246, 69, 81, 156, 52, 154, 123, 171]),key,iv))
print(decrypt_aes_cbc_with_ecb(bytes([171, 218, 160, 96, 193, 134, 73, 81, 221, 149, 19, 180, 31, 247, 106, 64]),key,iv),"\n")

print(encrypt_aes_cbc_with_ecb(b'hello world 1234',key,iv))
print(encrypt_aes_cbc_with_ecb(bytes(b'lovecryptography'),key,iv))

"""##Week 8 - DES"""

from Crypto.Cipher import DES
import random

#tables for key generation
key_shifts = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]

PC1 = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63,
       55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4]

PC2 = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55,
       30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32]

# tables for encryption
IP = [58, 50, 42, 34, 26, 18, 10, 2,
      60, 52, 44, 36, 28, 20, 12, 4,
      62, 54, 46, 38, 30, 22, 14, 6,
      64, 56, 48, 40, 32, 24, 16, 8,
      57, 49, 41, 33, 25, 17, 9, 1,
      59, 51, 43, 35, 27, 19, 11, 3,
      61, 53, 45, 37, 29, 21, 13, 5,
      63, 55, 47, 39, 31, 23, 15, 7]
IP_inverse = [40, 8, 48, 16, 56, 24, 64, 32,
              39, 7, 47, 15, 55, 23, 63, 31,
              38, 6, 46, 14, 54, 22, 62, 30,
              37, 5, 45, 13, 53, 21, 61, 29,
              36, 4, 44, 12, 52, 20, 60, 28,
              35, 3, 43, 11, 51, 19, 59, 27,
              34, 2, 42, 10, 50, 18, 58, 26,
              33, 1, 41, 9, 49, 17, 57, 25]

# Tables for function f
E = [32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21,
     22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1]
S = \
[
    [
        [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],
        [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],
        [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],
        [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]
    ],
    [
        [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],
        [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],
        [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],
        [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]
    ],
    [
        [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],
        [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],
        [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],
        [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]
    ],
    [
        [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],
        [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],
        [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],
        [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]
    ],
    [
        [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9],
        [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6],
        [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],
        [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]
    ],
    [
        [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],
        [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8],
        [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],
        [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]
    ],
    [
        [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1],
        [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6],
        [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2],
        [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]
    ],
    [
        [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7],
        [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2],
        [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8],
        [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]
    ]
]

P = [
    16, 7, 20, 21, 29, 12, 28, 17,
    1, 15, 23, 26, 5, 18, 31, 10,
    2, 8, 24, 14, 32, 27, 3, 9,
    19, 13, 30, 6, 22, 11, 4, 25]

def bytes2binary(bytarray):
  result = ""
  for b in bytarray:
    result +=  bin(b)[2:].rjust(8,'0')
  return result

def binary2bytes(binnum):
  result = []
  len(binnum)
  for i in range(0,len(binnum),8):
    result.append(int(binnum[i:i+8],2)) 
  return bytes(result)

def bin_xor(bin1,bin2):
  result = ""
  bin1 = bin1.rjust(max(len(bin1),len(bin2)),'0')
  bin2 = bin2.rjust(max(len(bin1),len(bin2)),'0')
  for b in range(0,len(bin1)):
    if bin1[b] == bin2[b]:
      result += '0'
    else:
      result += '1'
  return result

def bit_permutation(bits, array):
  result = ""
  for i in array:
    result += bits[i-1] 
  return result

def bit_rotation(bits):
  result = bits[1:] + bits[0]
  return result

def left_shift_rot(bits, steps=1):
  result = bits
  for i in range(steps):
    result = bit_rotation(result)
  return result

def create_DES_subkeys(input64bits):
  permutedkey = bit_permutation(input64bits,PC1)
  c0 = permutedkey[:len(permutedkey)//2]
  d0 = permutedkey[len(permutedkey)//2:]
  cn = ""
  dn = ""
  permut = ""
  result = []
  for i in range(16):
    if i == 0:
      cn = left_shift_rot(c0,key_shifts[i])
      dn = left_shift_rot(d0,key_shifts[i])
    else:
      cn = left_shift_rot(cn,key_shifts[i])
      dn = left_shift_rot(dn,key_shifts[i])
    
    permut = bit_permutation(cn+dn,PC2)
    result.append(permut)  
  return result

def f(in32,in48):
  expanded = bit_permutation(in32,E)
  xored = bin_xor(expanded,in48)
  result = ""
  for i in range(0,len(xored),6):
    bn = xored[i:i+6]
    j = int(bn[0]+bn[len(bn)-1],2)
    k = int(bn[1:len(bn)-1],2)
    result += bin(S[i//6][j][k])[2:].rjust(4,'0')
  return bit_permutation(result,P)

def encrypt_DES(key,message):
  message = bytes2binary(message)
  key = bytes2binary(key)
  subkeys = create_DES_subkeys(key)
  ip = bit_permutation(message,IP)
  l0 = ip[:len(ip)//2]
  r0 = ip[len(ip)//2:]
  ln = ""
  rn = ""
  temp= ""
  for i in range(16):
    if i == 0:
      ln = r0
      rn = bin_xor(l0,f(r0,subkeys[i]))
    else: 
      temp = ln
      ln = rn
      rn = bin_xor(temp,f(rn,subkeys[i]))
  result = bit_permutation(rn+ln,IP_inverse)
  binary2bytes(result)
  return binary2bytes(result)

def randomtest():
  key = bytes(random.sample(range(0, 255), 8))
  plaintext = bytes(random.sample(range(0, 255), 8))
  cipher = DES.new(key, DES.MODE_ECB)
  result1 = cipher.encrypt(plaintext)
  result2 = encrypt_DES(key,plaintext)
  #print(result1,result2)
  return result1==result2

def are_random_tests_all_passes(numtests):
  result = True
  for i in range(numtests):
    result = result & randomtest()
  return result

print(bytes2binary(b'\x01'))
print(bytes2binary(b'\x03'))
print(bytes2binary(b'\xf0'))
print(bytes2binary(b'\xf0\x80'),"\n")

print(binary2bytes('00000001'))
print(binary2bytes('00000011'))
print(binary2bytes('11110000'))
print(binary2bytes('1111000010000000'),"\n")

print(bin_xor('1011','0000'))
print(bin_xor('1','0000'))
print(bin_xor('1101','1011'))
print(bin_xor('10101010','01010101'),"\n")

print(create_DES_subkeys('0001001100110100010101110111100110011011101111001101111111110001'),"\n")

print(f('11110000101010101111000010101010','000110110000001011101111111111000111000001110010'),"\n")

print(encrypt_DES(b'\x13\x34\x57\x79\x9b\xbc\xdf\xf1',b'\x01\x23\x45\x67\x89\xab\xcd\xef'),"\n")

print(are_random_tests_all_passes(100),"\n")

"""##Week 9 - Hash Functions

"""

import hashlib
import itertools
import doctest

def sha256(message):
  """
  >>> sha256('I')
  'a83dd0ccbffe39d071cc317ddf6e97f5c6b1c87af91919271f9fa140b0508c6c'
  >>> sha256('love')
  '686f746a95b6f836d7d70567c302c3f9ebb5ee0def3d1220ee9d4e9f34f5e131'
  >>> sha256('crypto')
  'da2f073e06f78938166f247273729dfe465bf7e46105c13ce7cc651047bf0ca4'"""
  inputmsg = bytes(message,"ascii")
  hash1 = hashlib.sha256()
  hash1.update(inputmsg)
  return hash1.hexdigest()  

def authenticate(user,pswd):
  """
  >>> authenticate('admin','admin')
  True
  >>> authenticate('admin','admin2')
  False
  >>> authenticate('user','hello')
  True
  >>> authenticate('user','helo')
  False"""

  users = {
      'admin':'8c6976e5b5410415bde908bd4dee15dfb167a9c873fc4bb8a81f6f2ab448a918', #sha256('admin')
      'user':'2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824', #sha256('hello')
  }
  authenticated = False
  for u in users:
    if u == user:
      if users[u] == sha256(pswd):
        authenticated = True
        break
  return authenticated

def hack_sha256_fixed_size(pswd,length):
  """
  >>> hack_sha256_fixed_size('8c6976e5b5410415bde908bd4dee15dfb167a9c873fc4bb8a81f6f2ab448a918',5)
  'admin'
  >>> hack_sha256_fixed_size('2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824',5)
  'hello'
  >>> hack_sha256_fixed_size('a819d7cd38e9101be2e496298e8bf426ce9cdf78d2af35ddf44c6ad25d50158b',5)
  'crypt'
  >>> hack_sha256_fixed_size('688787d8ff144c502c7f5cffaafe2cc588d86079f9de88304c26b0cb99ce91c6',3)
  'asd'
  >>> hack_sha256_fixed_size('7ec658e98073955c48314d0146593497a163d79f4e1dfea4bab03b79af227214',4)
  'elte'"""
  chars = 'abcdefghijklmnopqrstuvxyz'
  combinations = list(itertools.product(chars,repeat=length))
  testpswd = ""
  for c in combinations:
    testpswd = ""
    for ch in c:
      testpswd += ch
    if pswd == sha256(testpswd):
      return testpswd
  return 

def hack_sha256(passw):
  """
  >>> hack_sha256('8c6976e5b5410415bde908bd4dee15dfb167a9c873fc4bb8a81f6f2ab448a918')
  'admin'
  >>> hack_sha256('2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824')
  'hello'
  >>> hack_sha256('a819d7cd38e9101be2e496298e8bf426ce9cdf78d2af35ddf44c6ad25d50158b')
  'crypt'
  >>> hack_sha256('688787d8ff144c502c7f5cffaafe2cc588d86079f9de88304c26b0cb99ce91c6')
  'asd'
  >>> hack_sha256('7ec658e98073955c48314d0146593497a163d79f4e1dfea4bab03b79af227214')
  'elte'"""
  recovered = None
  for i in range(10):
    recovered = hack_sha256_fixed_size(passw,i)
    if recovered != None:
      break
  return recovered

def hack_hashes(): 
  # THE FOLLOWING HASHES WERE GIVEN
  hashes = ['e06554818e902b4ba339f066967c0000da3fcda4fd7eb4ef89c124fa78bda419',
            '8aa261cbc05ad6a49bea91521e51c8b979aa78215b8defd51fc0cebecc4d5c96',
            'f2b826b18b9de86628dd9b798f3cb6cfd582fb7cee4ea68489387c0b19dc09c1']
  
  # The following plaintexts were extracted from site:
  #https://hashtoolkit.com/decrypt-hash/?hash=f2b826b18b9de86628dd9b798f3cb6cfd582fb7cee4ea68489387c0b19dc09c1
  # by inputing the previous hash values
  plaintexts = ['cryptography',
                'romeo and juliet',
                'vulnerable']
  print("LONGER EXAMPLE")
  for i in range(3):
    print(hashes[i], plaintexts[i])
  return

def authenticate_with_pepper(user,pswd):
  """
  >>> authenticate_with_pepper('admin','admin')
  True
  >>> authenticate_with_pepper('admin','admin2')
  False
  >>> authenticate_with_pepper('user','hello')
  True
  >>> authenticate_with_pepper('user','helo')
  False"""
  pepper_prefix = 'this_can_help_to_confuse_the_attacker_'
  pepper = pepper_prefix + pswd
  users_with_pepper = {
      'admin':{'passwordHash':'89e6b5ed137e3864d99ec9b421cf6f565d611f4c2b98e31a7d353d63aa748e9c'}, #sha256('this_can_help_to_confuse_the_attacker_admin')
      'user': {'passwordHash':'6dc765830e675d5fa4a9afb248be09a0407f6353d44652fd9b36038884a76323'}, #sha256('this_can_help_to_confuse_the_attacker_hello')
  }
  authenticated = False
  for u in users_with_pepper:
    if u == user:
      if users_with_pepper[u]['passwordHash'] == sha256(pepper):
        authenticated = True
        break
  return authenticated

def authenticate_with_pepper_and_salt(user,pswd):
  """
  >>> authenticate_with_pepper_and_salt('admin','admin')
  True
  >>> authenticate_with_pepper_and_salt('admin','admin2')
  False
  >>> authenticate_with_pepper_and_salt('user','hello')
  True
  >>> authenticate_with_pepper_and_salt('user','helo')
  False"""

  pepper_prefix = 'this_can_help_to_confuse_the_attacker_'
  pepper = pepper_prefix + pswd
  users_with_pepper_and_salt = {
      'admin':{'passwordHash':'d3eab7f4d6974f1db32b9cd9923fce9b434b28dc229b6582b845f1fca770d9f7','salt':"5294976873732394418"}, #sha256('this_can_help_to_confuse_the_attacker_admin5294976873732394418')
      'user': {'passwordHash':'976c73e0b408c89df3c1a12c3b0c45a6fee71bc1de5b47a88fae1a5e69ba6e28','salt':'1103733363818826232'}, #sha256('this_can_help_to_confuse_the_attacker_hello1103733363818826232')
  }
  authenticated = False
  for u in users_with_pepper_and_salt:
    if u == user:
      pepper_and_salt = pepper + users_with_pepper_and_salt[u]['salt'] 
      if users_with_pepper_and_salt[u]['passwordHash'] == sha256(pepper_and_salt):
        authenticated = True
        break
  return authenticated

hack_hashes() # Longer example explanation
doctest.testmod()

"""##Week 10 - RSA"""

pip install pycryptodome

import random
import base64
import doctest
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from Crypto import Signature
from Crypto.Signature.pkcs1_15 import PKCS115_SigScheme
from hashlib import sha512

#Given precomputed key
p = 11003378959096834724676546774061387323366640315376248759704778733861819318638880334019013198255253637201505215283454116581559061011493945035043282347726567
q = 13352889525665842987778367770008624367016738648357150498263337383873676994755016453139838515936896298380832735119884881555123452210776892442746292021125831
e = 65537
d = 69357425854335667435469380960551384845473529705172208755274378055130556220144321336280182386572376501722777078239543992605048261113781725370395014753635278111987701312950756882999549218951256463733424485080811858880863848299798658061367375851385442141410733493910441693585064588874291332393795622978366749253

n=p*q
phi=(p-1)*(q-1)
    
def encrypt_RSA(m,e,n):
  """
  >>> encrypt_RSA(1412,e,n)
  86570912637207688430658050442534138686860113447750593750129115867611069795980400149875084938172511059077111775763831984800728158009625476246509869646143906270016350813522907485120229804954044822840485338235665911639144492389863191230410694146471337610863228296869316878318424832455813948760206789878680061806
  >>> encrypt_RSA(423523131313,e,n)
  83815489698949425454503411340462271441833577560361070073340854340767697288862182622524598818990559851595417109271788865693175864183668088463270319213547090274280405302127646890044893707234611412838644930391470657208403905675470886164666899520786460799826428450507750448082240371010595240565614073056710598296"""
  return pow(m,e,n)

def decrypt_RSA(c,d,n):
  """
  >>> decrypt_RSA(86570912637207688430658050442534138686860113447750593750129115867611069795980400149875084938172511059077111775763831984800728158009625476246509869646143906270016350813522907485120229804954044822840485338235665911639144492389863191230410694146471337610863228296869316878318424832455813948760206789878680061806,d,n)
  1412
  >>> decrypt_RSA(83815489698949425454503411340462271441833577560361070073340854340767697288862182622524598818990559851595417109271788865693175864183668088463270319213547090274280405302127646890044893707234611412838644930391470657208403905675470886164666899520786460799826428450507750448082240371010595240565614073056710598296,d,n)
  423523131313
  >>> test_result = True
  >>> import random
  >>> for i in range(10):
  ...     test_case = random.randint(0,100000000000000000)
  ...     if decrypt_RSA(encrypt_RSA(test_case,e,n),d,n) != test_case:
  ...         test_result = False
  >>> test_result
  True"""
  return pow(c,d,n)

"""
print("n = p * q = " + str(n) + "\n")
print("Public key: (e=" + str(e) + ", n=" + str(n) + ").")
print("Private key: (d=" + str(d) + ", n=" + str(n) + ").","\n")

"""
#----------------------------------------------------------------------------------------------------------------------------

ciphers = [
    b'fkQKtKSJR0xafjo8dn8o8yseq90I30z1jofzB0Qu0SiUosyKzqNYR9Oh08zgnbK2/C3j8pHyGK7kadH6aFHCQoVkDUFva8H5jJcJbCfJj8u4z3396+acsqPhVeGg6M6L/nyygsTz2aIB7+tVUkVZiqwZK/p96xdAlB4gOqIDjBFyVBJDAPOi9NMBW4nyPdK3WhqVtXCDWoTTqhbSWrJcm7FcMQZlai8XT5C3f6TkUjf8ktyZWj9yZHWlhdhf8HKtdSq4y3VMWKufYa9EbYVEDoSF2iGxe4CkOv1QiNqjDLllT+tdULpm0EAa1WtJhG4LoWPt4TEW+0KVDJrg9Xcgsw==',
    b'O0d5jJC8X8OPc9jFG0eHHEGHxXTqc8tuVFMShxCn3rrBBGOShNO4Kx1nfnoL8SvQjGMdSNV64xh53ohwMGZhGVlj9FL4ydDrWhc0U74jI7REQODCXdXWZxBB0aKn/rPsPcL9h6957cof0z6H8XJtpTYcpgTV6UthEqwGIvf2qnxqpGC8WCbKhuXjqxX3JCmfBOripqiN/XgjNhpET2AVXEVJayo0dW4RTLi6k2VctXhkhK5YAfB94AbaEIfpuJiMfqMEedkle1YcMVI5tsMN1KwIcLkvBTctT6vvNWr+YXD45WlpZo1sCTpVsBfSU1vqfzxkOU3mdHKaCMOADxok6g==',
    b'TcEAH3j8dy+ZlkV9hpD4G3PXuHNnOBYsEjt9OGWsaIU03D7EA+L0BU8/1QRAhemC3l2jKChmQXLRpb89dpz2yJCM6JcFPT/nMRNmXxQD9l3dqmwdOTWlZ03SXa1IrQoSfOSzwOOmeAI+7Vs+bypJbPKIoOLxjtHNnDhWkSJ23Kfk1Gi3Y/XqhZgyFxejY8k8eg7PfLXU62S/zVd6T0HmDljV2w5iQqC8mgBLCr0ZFwMY5U3/NeWxxbZih1cgN1mk1UgE/PeshwoBr/VQGTZgsyOcq4BN3R3LpDrFFw1eP085WXsC+il6Uoe8rEod3MxfaS9tisFWiXfcf7xU/VzQsw==',
    b'MnCqdOXNssZprkjwlymjUC2qhmhoRdYoCl6m2edKw9bRh78KjvGWzXVMbAYxQRoMcpfPjrBHnuirOwU/LceNLnHGN/mTuWkf72erfhzIYvRcyvMNiAn2uWk6c31gO3Opyc30T7HcjxGxzKaMtAP899t3daEIH9SkJ1ILo4X4wnVZTMOzK6VpBM9aFPY0KKanjryaPgcbkPH8pT/BiRnDZpVRX7lkjxuK4mEQnYTNAJB6iZ/aZlHdlYo0M9OKR6FJSJcnl6wGh5wwxqg6JmW1Jv1cIZviibUip97hUNBmUgZcRT5gFLlnUBLZ/aON2BVJPh0DyBFGi0jvJ7bbclGWtA==',
    b'UftzvH2m4/rtFsArr2NdUC4fSUZhTzqwwXiuesX+eLR5qWHrRE91bUWxBSVi5xR67u5JcCsffzhro4ipUe1vgEyGhJTYxYOHs4P6TraTH0P0r9VFaD5PckaZsz0ClFbnu/iCUMvzc9uBdob8JYosUyJiUFinnzzLR5Q/YPjnoabjh7AdxHEZs7rHKeY9Tim+rsfpxvdtzUgw6ktSotA2QxuyOshcPxjXTTdriCI/g5IxXi/jFbYG2yazbcptYfuY/gT5NAIduIM1NMpDVP0Tbi+1Fo1kzU3AFwMwIM/6EpysnqrlFJlerwFBTy/qnUNKznjdJNsUzzkvRZ1+XEfzHA==',
    b'f8OgNf/XhUmUazQqMwRbv2lNH7pFk4/SNagr6JOm7+E+ZJuW0WrSpP9qaTxSsRB7a3OsjKwR5o0JixWpcp8JHr/E7FMnRL6TFQlU8yGJFNy8HWxi/jAdGm8fOvjsdwqw/yyA6ilTIHbBYctYb3LvOLCpRKbFKba4c0jAPSISdbEpP7Un7lmK5HGfPVhQ3lSB9Xp+8AMQYSL3RXp36Bxy019QWk6Q5CZj6e4e77sWLHxJd22eAV8nyV0HIxg82oEeXV+vcpy3kk71D1RbKeFSshTzLcu0HWmUfaAIROPrxsgWHzWQEY53OrnfpxWbGItJ2xAdPXJvGosLgE4lRBAHaw==',
    b'QzSIAj4kOCdkjhYX2kNoRxybIDBt8ckJBDYKx3th7TWFkGlnocYV7xgqa7xsCp1xyXkf3IltR4LYwLWwKKHblZ1DIICok3/6GpQ7VJ1U2Ym/ZGrOQ4w500Gv73giUL1vzNBidmmOJaq2qz54Q2xaHtY2urXa33xhiwCBxM81HpvjNeJvj1IJ09+9qGLk+QWNbNjmRrCDechbaMu71I4Zb4RPMI6uHIkSZzsoTkJAg3+IVbCc57OpjMQb8K8oL/BZePtIaDxvAI9/YxZLVeZSeuN7LjjZGUcVwCtVjr8athcfD6SDIcOAbrAEYiNs2LBdMC0IglmK5p6DFhtG8sTCbg==',
    b'C2aJcd9kgP5WFK9XkFUJKLbanLMcAoAV0aaI/1hVfkTB1O++jeNagyLgMtAN8RtC1ucDf/ThIrHU4o7ag+mjVkXUUFTK/gimPQl9wnoHRDUZa3bAik28kdF4Hf9Jj4fzTS+vQ7yvC2DD1XdWcKMucjgOhzTlihSmDkEvGZmhtmgfc3H5fsi0CzjW8rLJVhvtKsmNTWXz49slBixc9AEYiliox1kuw5SKMpgcnGW0pwQqrczAaNg+Y//ltKz7xYR+oDagkIlSRQOUpwfMdn05flRyNAhdWb4+aM/R6atSiNaJtBO5byabU0N/fXc2zhsajET/yxEuqIa3FGYUzv18Zg==',
    b'CB7QphKYRp5O7FajF4oEDMnQg15U9uSyQN2Lb3+ukN3ft4T/nHf1Bv5eSpsXWtDQGNVQh/6hluVK2ExLEjntpB9IhCZHKYDH4d5AL6AQs0AWpAfCoIAWKEH51nFA2rFWg7pa7V0Rh95cYXvLMGR0xlQcqXJpKVyv4EhD4nPXtrSSbwap/TlyoVCk051GDqEmUQuflONCJIbBEAioRc2pzyJ03oiiK3H6IMni6TAaqPG1HBOQYT1TbX6UpVWQm5gPqqFp+XPcOec8SlhyPMufrXBF6kawxGhQ4Bk3xHNVmE6bxCmlFk7095QIzJnbpCx3DRWvV9CT4RfgIxW1qHwSXg==',
    b'MQRaAwwloljDgzH+wTtY/l16l8oBpggykK9ld5mckuvTc1KcjtKf58r8QTADusZhPPtUlsvMVlomh9WoPIhBmm+o0q4IhBzob35jvtBSKlJlgcRYUee0+RZBojIQaKkMe2OFHsT1Fn4IK4KejVZiVh/GVYkbw7CJAuQW56pKgXHOQOTRNj1t6TD+KstIYSZ5Y0S17IYo9EB/f3jUPxmLLPlp+fuYz5lJIVKsH3zh7UJ19uuQat93ezuI9j5f/FapGuw0704zBO6ufmkM9BAt3M5S1CDkJqs1Ve6XN/EruMyqZK4snumhkB9KRl+j9KKwOVL1MkM/2EDX420iRh31oQ==',
    b'ozp8X+E9VGx/IAwVDhyNwacjMZt2xTSa8mqlIERO5qXTCPcYpSMvzidxybZyEJP4047cMCXz3aePO6oUYlW4Osry9El95p0adeoUWBkaiEIRNuHcOM6rO/oFUTwiKavmEIEdDFI0t4F1FBHbC7p+j3H3a1Izar7TMpHiJ+UYyqt2SAetjCmgFMYpUpe8vdLdU4Gcujf/aMt32wmzFXvg3q+DGHAL+NvjjBj8oJ6GzKa2nsfWEBiKRZixPMlV3H4D4hUhxHQOWALjhKfggV8zFZR1VHp1r3/jOdF5shgHIIM+j0gxPW/MfvXmoMPCqQyMmA6AAjJ7nEai78goEG44Ow==',
    b'TN5a8ejPt7bBR8xldIDFZr1ytNFPcF6FVmHURymlENJysXa2CKp6PmHy6sjFCVulngRuWbm4snOgOa4PxFjic7FNVAO1oWm2cEGoolVQQQ+zdGIhpHZLLwIDSnCCHev/sgF/kUHG9ZU8meid3qjXC47IQ6637yfvElNkZsYEIam4qiaM/I/fa9Cyfoio+uBzG8RBiHudFJzwy86/icys8TIUd7bxKIXDvRem2eqOtADbbnF2rPl8kiIg3c5Cv4hssCT/jQqtzEf+FApTI5jwPL6dDHhP6wrtllB/1nCl1U3JyfWte0iicxDJSQPOcfVvf/8Kne7d+9ud5KgOJ/m04g==',
    b'B1CKW0KBqoit4aWueBVfA4RFLisrsv5h6DH4okH29svYAJKV65SW5+GJd+bWyESohdtdnqRegSQZaaslLiQg6Z9pJIso3P7EfmYyioajsDfJic6KNazagRo1kZjNqrzD0Ny0SVPQNmXVEJsejZvjkDt97tqnLhyy1soR5Da3zvMVQgQ7m/OH1rStcikZHwTPCeytLM60kBRYRREDrcU+urkEokkaVOYXN5Zvg9dUhhoSl3ohKU+rJNBFaySAre70ffMSN6mPy6gGmaHRIhgoEl9RsaDp3nVAyJape2UjRIGdCFqV5Wd4HI1fy4OOMDVxjbUJBih7mVzcHf9CHszuvQ==',
    b'KeswSWZM0DitUpwaab138tWVq0p5vWurWnFTyBS7gHzEWIHO93YSuMbYmVkyYunC1C74z56WVwQPUBZszW0FztTFi3nxU3nol1VjJfs3lncx9H+xk2P497dm2b/PTZoUMLS7BNBgdbZCaX7G/de6aG+hLKIlVq6xFT8bGF8rYMt+hD4CET3VjCt3tgjF/btfihlLjDyzqPcdqaUtSJzQm4uawCPX6R0P2LVy7O0GyWrXAccTi2KFnsoaXdnQsSlKE+zbiQwcS9OaYnEeGlYcb0YzJfrchRFI9a/ulhWrcXI8f7BR3lR956Q9izTAEja8QmW4a02dBN5m41y/x/ztqw==',
    b'LF/PtlCw5e3Iv4ypakOchSe0MTFsJ7wqzz09QerFNx1mJAmyHifuUUzrUAM+VEHI+MDzSkUc3hdnscmMxVy/ZJpWfFc3UqmfNdyESFBZfnRq2SHm7FrYzREQBWBzQz5DCVSSasx4WF97TEY8ajmeR6LiB2xSFtcA9BqXZ3TEXAlwlLnhqa9wi0ihX+lmdvCySuzz0cq3ZsHFBoNGCdhyC5ZfjLzi5wfFWPAkNi+RH7ciMQFtm0rbGr3wZ522ReeToyIzkCFCWQukl0dqt8mYwSPSWaZbdlQYxIMN9UpNwiEVU7jWoaMDxPrqdIs1SF0ejV261YhyVgIejh7XkowSnw==',
    b'BlFHM9RGBbVCJ7b03cyooHlv+DsrNUokP2CR+bCkI8cbueZpNBN0poZYafMv7qR4D1eayyvVrwAOCj9KGHKzJpkPnwjg4thuXnH/ZEinsqyVvbg7dpQSzRsM6dxH75whBofJXvzabzDIpORDn+QG6RGxc6VLdQyAUQ7LWrL6D7GCMwwO+AHhid+4r23jTGYncbotwmDsv4YS3aoNhbPFHBzni64i1SeZUnMDiVA46zsDDbNH83V/glo6mTFl7xy2BYak+ohMDJiiNbrVdT+NF3nOD+jIqz7vBsKItzN5NEtaQMkubE18vqCSLgFcaoYLKkI1SB5T/g9fhILtcuxipg==',
    b'Zs+afNP9lHzPPUEOJLTjnQGbiisGy0s2cNsX6I/fEP7/maL1T1gSyAkeKrg3x5bYbep5YNMWOTqIRpXevnGnFvB+zqPw2te3E/saA2Y8xnJOSd1bVLoa31EuLF+H4s7oTSjdJDZsvjP5I7ARZanPOQiru+PCCp5oo/Ab3UladhY5As7bEw7A+YEfKERLVfinj/dX8IsaNpuq9BkomvyyxGTiBjRFHGHrZLML1LowoLhcOZ0Z/vFeIr7rhl8S93hzfeBw1RhIAN74k0F4POBNWNTt4CljTABV+gvvglv7rU1OZWMk0LAzP9bTrLXFAEYcERe9OIRJV7hnVAlljmUa9A==',
    b'xreXej7YGEo8th3+CYLMG2RTx3zFETLtlfdYB4TDdIj4/DZ5MOmp7jMiS1rewXmJLAKE1YATXBapNnp8IuFgjURzRxwQ+tlIOA33BAd9t4yLMn8W2+JUcLHOVOcDjVviqOOE9YKsIDhIDQVkmHV6XnvqyIUveA/vH4J/QOQuLV9cv+cmCpBD9S5wL2NyhqhjzTUvrnJq4MQg2b6ZnGjASaecAeoYu3VyG/60N3XBzY5+f5CIX8JfjEJ0ZXNwMhpigqoFFmv1FIFfi4+ChgSsdj5f7o7C2ylU+vo1ao+lrTgtqnI6HzSUF6uAuD01ZjT46aLRfVfsrFilKoIUoAtxiQ==',
    b'ZBdRxsGAm5PJ7QiCAt/S7FUU0Qqdq+6Gap6IDLCdjor2W3Vu4lEt+tjazmJXJ4FUwVc3yW83xejsRG/XbkAQu/AunZPN2CRdoDkRUNWghMY/muDPuXpkiLTbvSSq2fb0aGtwfCceXS2SkN8aIZqOQddqS+jhaoVzRyblrbsZGFcQCynXzoI7jZBvBrnfH2KOsPM88JiqEWvDQltYWTg8j688GAcH3FsAuXhkmj+8EflbxHR0WvC+srMtQls4Oqc4PrJ+UuToL/ezHK6hLfTo9sujQRhlGVnFdcojBzbW+n84fubBuqAHMXkZzdSyjicGlLamYa/btppPsJ8MFNGYCA==',
    b'SYapMoN/T/5/tRQlZnsISZ9vtKmMZnEK5kq4x/WKHnBhDZTtzsYpwsB7r49Ee3TvnkbJo2S+FQOdhcslceQvIG3W7kdc6CvJ/3P5LsGjCijvTOtiDPjXlzRrzYyksUKfG1KNfCaqgTrNxiTGO2/9uKX5/ZcNpTnVO8UpV4HAodyOEUsVOGo+WP25Pp+7BEpOkSGqTjPFz/pwKFIl7N50EnPYjfjwIg12+Z5KyG7bXJbTN5sAQwEylf7P+KaEGk61A7SzJFAd8TYMx+0pC4ibS7vXh2NoBHx4mh1VoDnxfihklLEW+owaogJeD6LvKzajNo+QvEgtQvBp7caBV2K/ng==',
    b'cgUEyPODmmGvNExGXEuWYI06GyGeSNTefk8SrW7qDJBDm2oYOsoRjmC0xjeguWlGsc2TBvqTOXlSMvOn8wlCWJc+eJi5/XqeE+Th5CA5lCrd7ATlZSh1gF7PU46kbHr6WDAfmQvYayFmLR9IgAefjAbrHMDjsMkoWHN34JliQQCCcrG+N0OZEW1Qlar08pblRadRcWJ9fY5gZtO/ug2AsY6CZr65ueU2GonupzaXOJLe5hb4NQclk38mf5sr/BAFni623/ES1xHO56jkReSgZ02isrxF+sjIVMimMuElzx5A7Hx8scEY201qA0eCE013b7WaS4t5lUKjHJKJALyMlg==',
    b'LsriyazGHs06tMujKcDSKfvg1cmDgV3ml2Gx0qA5m0AAl5W4T3c3Z1kGdOrAeG632oX/aTGOpja1f85pmlj32QrNqdWT56cyTrj40c5ougHIhpJjaiML0cc3k0LeGMjSZtlznUCLSyKgZJaa2tHBFSsY2kODwtNlpBQf+IWE73NceQaNaQ310mbmV7u+z1nK+zq1ij3dsEloprQujR9WRYzQZIDtti87iIaLe4tb9XXbEZ0eREx9tfDP1QCEzuzaC5txnghX4bR6lMgporzp/5Rk2cq1C2HVQZuz0rBRdfMfRdC/nLLTzo/JveS4btnk3aGt4KPw7WKea3hzErxNBw==',
    b'bFWuwPKVYnjRuxYGATyZvTA1XNFAmjjtBpp9be0y0JNFD+Zd/XvJyYTPgJbhqxhc8+aeXs3iT66a+oxplWpS/T0T0FmLVAccLdwYi7hESfg7F4RZJbyLSDKTUkslPTF87PjoJr579lxMflutx6shvkAZm10p7KbCHf20VOcmCK/AaTAvf10/HBo4Ex4Z767fMAnjVRK65fQBE6/7cPzSCXg3L37NTeiv1WHoaGv2Xx6+GbkxyZikYb7ZAVL+w5Log9l+3HvILYWCNHPSwUnnszaoqwzoTmwDrUkARd8L2z0YS3DUQJUO3Q2+mVGj6+y4fe+SGGq13VRP/0uy/KNyoQ==',
    b'IQHoYovLnFq8J+1qmB8ZQhaYsx99RKfKYnjmIsjPgdcGeQAQM8jqN5T9xYr+XNDQkZCGVhLpigQ00FGTi+lPnx7RJUOGqtrY6bZBrGO4xmZb0MdfKc1BdQQnLLUYkOwow86Y3pSUM0047wPOkDroqiippjrI8UDkya1lDruEihawdGIlVSYwrUfRUGUR6nxQmGOuyQB7fj+MhCRy2MNh/hu7lnfzTTCkHK2b25cjRGDa1p/ePajzuyQGbkf5fF5yybViYiS5lA9DG7Y3GMH76BD05lwbWsfFTvJmP3+XoHD3N4ZGzEZydHJbnnvE8rXW1QYogJAy+HWdQdETt7smJg==',
    b'd1rZcRrhJHADTdxVpX3ij+/F5/jsCq5I/XEy4b5CR8I7XQBuOKhHn9YS5dUKPEQeIZUphiTdrQNJwn/pp4qlDJJtODcAN82vB6CR0DORp7zPXCiLuW1aa7/THccfFRGGOP44jdcRoWDSb335IwY28Ubl886RUOEAV68Q7xzt4GtsZujr7Cf9sXfvPO+MTgBMAcecJRirqa6UoWfuRZGf0LXSwozynO+skJRZhpJuR9lq1/yEL2Dgx8ycl145EgmMrYkIbfm53SD/QH9tYYYILRl7rbq44M1emNtL2GIImNBmu9d20HpJgtDw9794sNqCtXE4zdqS0DmeYcsF7SEMxQ=='
]

key = RSA.importKey(open('secret_key.pem').read())
cipher = PKCS1_OAEP.new(key)
decrypted = ""
print("Trying to decipher with the given key...",key)
for i in range(len(ciphers)):
  try:
    decrypted = cipher.decrypt(base64.b64decode(ciphers[i]))
    break
  except ValueError:
    print(len(ciphers[i]),"Decryption failure. Try again.")

print('Decrypted:', decrypted,"\n")

#----------------------------------------------------------------------------------------------------------------------------

messages = [
    {'text':b'The code is uehqn', 'signature':b'IZceGm/mkewdAeS3wc+Qhk4L/55lRe9L2NwUSH2o0wSDnDnKnSMDQon+bLLnl6pvUtEhpjZoDGvC26TMRg2dXCDZiocNnFPMbBSa6nc+4yaDkbxtHWEhuXk3rOtbHagr8MQzuKBK0CJeZ13i+iMN7OLVpTsCxNpP9Fx96I8t1OtNAZq4yIz2f0MmAvDMdqDSnuX40RIzq11La8xuJPuCO872Y3eBFyPWFMxbpghTtlCQqcdyIy3EmBbnskA4Gw077TzKZJ5V5ntUYdVercSpJ9Ax0mDd/xmYFTmUHmb973NvIzlf//IJ/Q0IDdQObEvB2cVQpqeCxABpsCfxxJiBPA=='},
    {'text':b'The code is rplps', 'signature':b'fcch/RNP8K+Hqe7ORB6f58gAnPhA8kz35j33MqvxGz72YpQdQXicPCWYcAkqs6nM0tQ55mNqhMta+RSGtsYMFndpriKTZRXngPHS+CpFbNhIonQll+7zmPZXkEdNoB5TcdS7vkt26j+xn1u6mlCQgctZFa1RcXLZewkfsoofNt3e/1mqoE9MqZdpNgt+od8RQ7eKNMTrzQuTeabpCWcCgW12gBFoGRNG/cBUZKeskxwM264aaCgzgijcUCxEaN9lJDUvSmTDtncWlVoFt3vN8A8DXUzDUMOLb7sZca7p5U/aiJ7g0LDetzjK9IDWGAVqUa5rLBUGiX5B5uXcg95yrg=='},
    {'text':b'The code is zhijc', 'signature':b'Fwv9XATss7knUy+nyUU05E9bJS6zgd4cPMn7hbT/7mhl+hV7l9LP0A9ZJTNVwX1Z5tW+IrCPyPDFROtjmsGFmqBD5nmbDXp6YIZnn1atBG6mnlUQZ4F5Ph+vvvQUyB21r0fWWQ4m4U96V/SQ+/FK08NYj8qYplibZqXgKkszAF6dwIJhAZ8KVM8l8LY6djI5vghhtvd/RZuyig6PAqx5iY9nB/je1IZO3ntIUp+LfuIcHS5X6Vcc40okWAsQd8mDYzftvYUJnkcnxjfPUxgcJoyChC50psfo1LaUqsWRu2Ck0fC5DjiKj4tePf2sjenib9D3Wc8xuLkS6IyTQQeAyg=='},
    {'text':b'The code is ylaqd', 'signature':b'IL7oELlFaFr8FqOPc/1n3ATZufVsJFW47CGHpJu+zfp1K0YeOwWthw31MEAFMAXqg0DRbR14VEly2LE2MQxqLGjbf+cZE9aNBrck7GDtFeRz9G3gGysHanz9NoM55YbR56Fs+olj7BDxUnaF51wCpliUG+kNr8ApfxT0h5Nd8+4DIAp1rhzovrg7WZXPeOGE6h/orpizlbj331WGhKvimUGKjMannwdOtTnuU7ht5UGnZWIDs0TsXGK1Bn6a6ZcgNu5gl7emk1IbR3LwnJLOI//xj3t6RWKinDHdzwmaWrfwjky/UrFMMs54qgJWmGHB9hpEHcbHLJ1LvJwKOUDuqg=='},
    {'text':b'The code is bvxie', 'signature':b'pYjvtm2Ibjzvz5x1zmsHk60yIakkwXOJ2957auW2IAS2TRnsRTBSSSOhZdN9gixVL6YfpCs7AhgPS4u+ZLX+Y5sZIpr3FZHzRU7WGboYqxBWa8sOSXmOj+4B9v+r+A9mBAtHobdVIUmAd/FmHH9jHqSyGXRJw38mjkOlENTmjdwwKzPKCMcpCpVEHx9DzxzR4ELNtk5HtgRbBnjSxXJDND6kA45/IbcvPdznTIO42p+4J1tlKXKp283Wwlg7g02gSiboM+cVyt3kMjuOTYKG+DIIDcQObzgY3W6fWRVSGSIZaaOdR54ll6Kn79zG8W6nUjxUIZ9i1OMfT5G08zBfLg=='}
]
pubkey = RSA.importKey(open('my_friend_key.pub').read())
print("Trying to discover the original message signed with",pubkey)
verify=""
for i in messages:
  text = i['text']
  sign = i['signature']
  hash1 = int.from_bytes(sha512(text).digest(), byteorder='big')
  hexnum = base64.b64decode(sign)
  intnum = int.from_bytes(hexnum, byteorder='big')
  hashFromSignature = pow(intnum, pubkey.e, pubkey.n)
  if (hash1 == hashFromSignature):
    print("Signature validated for message: "+str(text))
  else:
    print("Signature failure. Untrusted sender...")

doctest.testmod()

"""##MOBISEC CHALLENGES"""

pip install pycryptodome

"""
Expressions for Java .matches(): https://www.jrebel.com/blog/java-regular-expressions-cheat-sheet
Decrypt hashes MD5, Sha1: https://hashtoolkit.com/decrypt-hash/?hash=2de1bdc5673c20ffb2a57e359064a6dd
"""



import hashlib
import codecs
import random
import base64
from Crypto.Cipher import AES

def computeMD5(s):
  hash = hashlib.md5(bytes(s))
  result= hash.hexdigest()
  #print("hashing...",result)
  #print(hash.digest())
  return result

def encrypt_aes_ecb(bytarray,key):
  cipher = AES.new(key, AES.MODE_ECB)
  return cipher.encrypt(bytarray)

def decrypt_aes_ecb(bytarray,key):
  cipher = AES.new(key, AES.MODE_ECB)
  return cipher.decrypt(bytarray)

def findvalue():
  found = 1
  pin = 624000
  while(found):
    hash = computeMD5(str(pin).encode("utf-8"))
    print(pin, " hash: ",hash)
    if hash == "d04988522ddfed3133cc24fb6924eae9":
      print("found pin!:",pin)
      found = 0 
      return
    else:
      pin+=1
      if pin == 626666:
        print("MAX VALUE REACHED")
        found = 0 
        return
  return     
   
def breakattempt():
  randomlist = range(48, 123)
  characters = [chr(n) for n in randomlist]
  print(characters)
  stringattempt = ""
  for c1 in characters:
    for c2 in characters:
      for c3 in characters:
        for c4 in characters:
          stringattempt = ""
          stringattempt+= c1 + c2 + c3 + c4
          #print(stringattempt, computeMD5(stringattempt.encode("utf-8")) )
          if computeMD5(stringattempt.encode("utf-8")) == "1885eca5a40bc32d5e1bca61fcd308a5":
            print("found!: ",stringattempt)
            return;

#findvalue()
s = b'5465567'
pin2 = 621903
print(bytes.fromhex(str(pin2)))
print(bytes(str(pin2),"utf-8"))
for i in range(400*25):
  pin2 = computeMD5(str(pin2).encode("utf-8"))

st = "Vm0wd2QyVkZNVWRYV0docFVtMVNWVmx0ZEhkVlZscDBUVlpPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMVpWTVVWaGVqQTk="
for i in range(10):
  st = base64.b64decode(st).decode('utf-8')
print(st+" _- "+st)
#print(codecs.decode(b64,'base64'))

key = "0123456789abcdef"
flag= "2ec552132149f0a9f3c92eef730a8ccbba64552828fdcc385b0836fa82cf9e6014e373c05943cfbfac2ee747b75d2e0a"
print("Size should be multiple of 16. Len: ",len(flag))
print(decrypt_aes_ecb(bytes(flag,"utf-8"),bytes(key,"utf-8")))
print(len(computeMD5("sd".encode("utf-8"))))


def decrypt_aes(bytarray,key,iv):
  cipher = AES.new(key, AES.MODE_CBC, iv)
  return cipher.decrypt(bytarray)

def string2hex(s):
  hex_string = ""
  for c in s:
    hex_string += hex(ord(c))[2:]
  return hex_string

key = bytes([57, 226, 240, 61, 125, 240, 75, 68, 22, 35, 124, 205, 144, 27, 118, 220])
iv = bytes([241, 147, 66, 129, 194, 34, 37, 51, 236, 69, 188, 205, 64, 140, 244, 204])
msg = bytes([255, 18, 67, 115, 172, 117, 242, 233, 246, 69, 81, 156, 52, 154, 123, 171])
print(bytes.fromhex(string2hex("mobiseccomkey!!!")))
print(bytes('hello world 1234',"utf-8"))
print(string2hex("0"))
print(computeMD5("0000000000000000".encode("utf-8")))